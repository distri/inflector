<!DOCTYPE html>

<html>
<head>
  <title>source/rules</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="http://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
        
        
        <li id="section-1">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="rules">Rules</h1>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">
</code></pre>
</div>
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>These rules are used by the <a href="inflector.html">inflector</a>.</p>
<p>This <code>matcher</code> helper will let us construct rules easier. The default <code>replacement</code> is the entire match unchanged.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">matcher</span></span> = (string, replacement=<span class="string">"$&amp;"</span>) -&gt;
  [RegExp(string, <span class="string">"gi"</span>), replacement]</code></pre>
</div>
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Another little helper to convert blocks of rules text into arrays of matchers. Each line is passed to the matcher helper to create a matcher and replacement pair.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript"><span class="function"><span class="title">toArrays</span></span> = (text) -&gt;
  text.split(<span class="string">"\n"</span>).map (line) -&gt;
    matcher line.split(<span class="string">" "</span>).filter((piece) -&gt; piece != <span class="string">""</span>)...</code></pre>
</div>
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>These rules translate from the singular form of a noun to its plural form. The first section is plurals that should remain unchanged. The next section contains rules and replacements to transform words from plural to singular forms.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">pluralRules = toArrays <span class="string">"""
  (m)en$
  (pe)ople$
  (child)ren$
  ([ti])a$
  ((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$
  (hive)s$
  (tive)s$
  (curve)s$
  ([lr])ves$
  ([^fo])ves$
  ([^aeiouy]|qu)ies$
  (s)eries$
  (m)ovies$
  (x|ch|ss|sh)es$
  ([m|l])ice$
  (bus)es$
  (o)es$
  (shoe)s$
  (cris|ax|test)es$
  (octop|vir)i$
  (alias|status)es$
  ^(ox)en$
  (vert|ind)ices$
  (matr)ices$
  (quiz)zes$
  (m)an$                 $1en
  (pe)rson$              $1ople
  (child)$               $1ren
  ^(ox)$                 $1en
  (ax|test)is$           $1es
  (octop|vir)us$         $1i
  (alias|status)$        $1es
  (u)s$                  $1ses
  (buffal|tomat|potat)o$ $1oes
  ([ti])um$              $1a
  sis$                   ses
  (?:([^f])fe|([lr])f)$  $1$2ves
  (hive)$                $1s
  ([^aeiouy]|qu)y$       $1ies
  (x|ch|ss|sh)$          $1es
  (matr|vert|ind)ix|ex$  $1ices
  ([m|l])ouse$           $1ice
  (quiz)$                $1zes
  s$                     s
  $                      s
"""</span></code></pre>
</div>
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>These rules translate from the plural form of a noun to its singular form. Like the plulization rules above, the first section contains matches that are already singular and sholud not be transformed. The following section contains the matchers with the transformations to convert plurals to singular form.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">singularRules = toArrays <span class="string">"""
  (m)an$
  (pe)rson$
  (child)$
  ^(ox)$
  (ax|test)is$
  (octop|vir)us$
  (alias|status)$
  (b)ie$
  ([br]u)s$
  (buffal|tomat|potat)o$
  ([ti])um$
  sis$
  (?:([^f])fe|([lr])f)$
  (hive)$
  ([^aeiouy]|qu)y$
  (x|ch|ss|sh)$
  (matr|vert|ind)ix|ex$
  ([m|l])ouse$
  (quiz)$
  (m)en$                  $1an
  (pe)ople$               $1rson
  (child)ren$             $1
  ([ti])a$                $1um
  ((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$ $1$2sis
  (hive)s$                $1
  (tive)s$                $1
  (curve)s$               $1
  ([lr])ves$              $1f
  ([^fo])ves$             $1fe
  (bie)s                  $1
  ([^aeiouy]|qu)ies$      $1y
  (s)eries$               $1eries
  (m)ovies$               $1ovie
  (x|ch|ss|sh)es$         $1
  ([m|l])ice$             $1ouse
  (us)es$                 $1
  (o)es$                  $1
  (shoe)s$                $1
  (cris|ax|test)es$       $1is
  (octop|vir)i$           $1us
  (alias|status)es$       $1
  ^(ox)en                 $1
  (vert|ind)ices$         $1ex
  (matr)ices$             $1ix
  (quiz)zes$              $1
  ss$                     ss
"""</span></code></pre>
</div>
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The common case for replacing the last s with an empty string, added separately because the text block can&#39;t easily parse the empty string as a replacement.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">singularRules.push matcher(<span class="string">"s$"</span>, <span class="string">""</span>)</code></pre>
</div>
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Words that should not be capitalized for title case.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">nonTitlecasedWords = <span class="string">"""
  and
  or
  nor
  a
  an
  the
  so
  but
  to
  of
  at
  by
  from
  into
  on
  onto
  off
  out
  in
  over
  with
  for
"""</span>.split(<span class="string">"\n"</span>)</code></pre>
</div>
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Nouns that use the same form for both singular and plural.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">uncountableWords = <span class="string">"""
  equipment
  information
  rice
  money
  species
  series
  fish
  sheep
  moose
  deer
  news
"""</span>.split(<span class="string">"\n"</span>)</code></pre>
</div>
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              <div class="pilwrap">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Export our rules.</p>

            </div>
            <div class="content"><pre><code class="lang-coffeescript">module.exports = {
  nonTitlecasedWords
  pluralRules
  singularRules
  uncountableWords
}</code></pre>
</div>
        </li>
        
    </ul>
  </div>
  <script src="https://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script><script>
  (function() {
  var ErrorReporter, bindUpdates, createEditor, exec, findInteractiveElements, readShebang, runners;

  createEditor = function(code, shebang, section) {
    var annotationElement, contentElement, editorElement, exampleSection, runtimeElement;
    exampleSection = $("<li>", {
      "class": "example"
    });
    annotationElement = $("<div>", {
      "class": "annotation"
    });
    editorElement = $("<textarea>", {
      "class": "annotation",
      text: code
    });
    contentElement = $("<div>", {
      "class": "content"
    });
    runtimeElement = $("<div>", {
      "class": "output"
    });
    contentElement.append(runtimeElement);
    annotationElement.append(editorElement);
    exampleSection.append(annotationElement);
    exampleSection.append(contentElement);
    section.after(exampleSection);
    return bindUpdates(shebang, editorElement, runtimeElement);
  };

  bindUpdates = function(shebang, editorElement, runtimeElement) {
    return editorElement.on("keyup", function() {
      var e, report, source;
      report = ErrorReporter(editorElement);
      source = editorElement.val();
      try {
        runners[shebang]({
          editorElement: editorElement,
          source: source,
          runtimeElement: runtimeElement
        });
        return report.clear();
      } catch (_error) {
        e = _error;
        return report(e);
      }
    });
  };

  readShebang = function(source) {
    var match;
    if (match = source.match(/^\#\! (.*)\n/)) {
      return match[1];
    }
  };

  ErrorReporter = function(editor) {
    var reporter;
    reporter = function(error) {
      var errorParagraph;
      if (editor.next().is("p.error")) {
        return editor.next().text(error);
      } else {
        errorParagraph = $("<p>", {
          "class": "error",
          text: error.toString()
        });
        return editor.after(errorParagraph);
      }
    };
    reporter.clear = function() {
      if (editor.next().is("p.error")) {
        return editor.next().remove();
      }
    };
    return reporter;
  };

  findInteractiveElements = function() {
    return $("blockquote > pre > code").each(function() {
      var blockQuoteElement, code, codeElement, sectionElement, shebang;
      codeElement = $(this);
      code = codeElement.text();
      if (shebang = readShebang(code)) {
        if (!runners[shebang]) {
          return;
        }
        code = code.split("\n").slice(1).join("\n");
        blockQuoteElement = codeElement.parent().parent();
        sectionElement = blockQuoteElement.parent().parent();
        blockQuoteElement.remove();
        return createEditor(code, shebang, sectionElement);
      }
    });
  };

  runners = {};

  (typeof window !== "undefined" && window !== null ? window : global).Interactive = {
    register: function(name, runner) {
      runners[name] = runner;
      findInteractiveElements();
      return $('#container').on('keyup', 'textarea', function() {
        $(this).height(0);
        return $(this).height(this.scrollHeight);
      }).find('textarea').keyup();
    }
  };

  exec = function(_arg) {
    var code, editorElement, runtimeElement, source;
    source = _arg.source, code = _arg.code, editorElement = _arg.editorElement, runtimeElement = _arg.runtimeElement;
    runtimeElement.remove();
    editorElement.replaceWith($("<pre>", {
      text: source
    }));
    return setTimeout(function() {
      return Function(code)();
    }, 0);
  };

  $(function() {
    Interactive.register("setup", function(params) {
      params.code = CoffeeScript.compile(params.source);
      return exec(params);
    });
    return Interactive.register("setup-js", function(params) {
      params.code = params.source;
      return exec(params);
    });
  });

}).call(this);

</script><script src="../package.js"></script>
</body>
</html>